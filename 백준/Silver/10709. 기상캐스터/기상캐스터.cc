#include <iostream>
using namespace std;

int main() {
	int a[100][100] = {}, H, W; char c;
	cin >> H >> W;
	for (int n = 0; n < H; n++) {
		for (int m = 0; m < W; m++) {
			a[n][m] = -1;
		}
	}
	for (int n = 0; n < H; n++) {
		for (int m = 0; m < W; m++) {
			cin >> c;
			if (c == 'c') {
				for (int l = m; l < W; l++) { a[n][l] = l - m; }
			}
		}
	}
	for (int n = 0; n < H; n++) {
		for (int m = 0; m < W; m++) { cout << a[n][m] << " "; }
		cout << "\n";
	}
	return 0;
}
/* ■ 설명 ■
문자와 2차원 배열을 이용하여 해결

처음에 행렬 사용할 범위를 입력 받고,
[9줄 / int a[H][W]] 배열 범위 전체에 미리 ' -1 ' 를 넣어준다.

그 후, [13줄 / char c] 로 입력을 받아서 유일하게 문자 ' c ' 입력만 담고,
문자 ' c ' 를 입력 받았던 [m] 번 째를 시작으로 
[16줄 / for [l]] 반복문으로 점점 증가하면서 열 기준으로	// [int a[H][l]]
한칸 씩 옮겨갈 때 마다, 1씩 증가한 값이 기입 될 것이다.(0, 1, 2, ...)

열의 끝을 만나게 되면, [16줄 / for [l]] 반복문은 종료되고,
다음 열 칸에서 문자 ' c ' 를 입력 받게 된다면.
위의 방법을 고스란히 따라하여, 무식하게 덧씌우는 방법으로 하게 될 것이다.
=======================================================================================
하지만 위의 방법 말고도 다른 방법으로 [int a[H][W]] 배열에
' c ' 가 입력된 열 기준으로 오른 쪽으로 옮겨 갈 때 마다 1씩 증가하는 것을
같은 열에 ' c ' 가 입력된 곳을 증가 연산식을 덧씌우지 않고 구현하는 방법이 있기는 한데,
그러면 2중 [for] 반복문을 남발해서 코드 줄이 길어질 것 같아서 임의로 압축했다.

다른 방법으로 푸는 것은 추후에 '_2.cc' 를 참고하자.
*/
