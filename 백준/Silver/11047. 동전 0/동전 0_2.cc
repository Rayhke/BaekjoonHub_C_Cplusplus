#include <iostream>                  				// 이 코드엔 중요한 문제점이 있다. 아래에 설명 하겠다.
using namespace std;

int s(int a[], int c, int n) {		    			// 대표적인 이진 탐색 알고리즘
	int x = 0, z, y = n - 1;			  	// 최소값, 중간값, 최대값 지정
	while (x <= y) {					// 최소값과 최대값의 존재의의가 크로스(역전) 되는 걸 방지
		z = (x + y) / 2;
		if (a[z] <= c && c < a[z + 1]) {		// a[z]가 [c] 보다는 작거나 같지만, 다음 원소
			return z;				// a[z + 1]가 [c] 보다 커야만 리턴한다.
		}
		else if (a[z] > c) {			      	// a[z]가 [c] 보다 크면 자릿값 최대 범위 감소
			y = z - 1;
		}
		else {						// a[z + 1]가 [c] 보다 작으면 자릿값 최소 범위 증가
			x = z + 1;
		}
	}
	return 0;
}

int main() {
	int a[10] = {}, b, c, n = 0, m = 9, l = 0;
	cin >> b >> c;
	for (n = 0; n < b; n++) {
		cin >> a[n];
	}
	m = s(a, c, n);
	while (c) {
		if (c >= a[m]) { l = l + (c / a[m]); c = c % a[m]; }	// 몫 만큼 [l] 동전(지폐 등) 개수로 카운트, 나머지(잔돈)은 [c] 로 넘기기
		else if (m > 0) { m--; }				// a[m] 가 [c] 보다 커졌을 때, 자릿값 감소를 하되 0 이하로 떨어지지 않도록 조건 제시
	}
	cout << l;
	return 0;
}
/* ■ 설명 ■
[b] 개 만큼의 동전(혹은 지폐 등) 종류가 있으며
반드시 오름차순으로 입력값이 주어진다.

[c] 원의 금액이 주어 진다면, 동전 (혹은 지폐 등) 종류를
최소한으로 사용하여 잔돈 없이 맞추고자 하면
최대 필요한 동전 (혹은 지폐 등)의 갯수는 몇 개 [ㅣ] 일까?
===============================================================
이진 탐색을 이용하여 배열 [int a[z]] 의 원소값 보다 크지만			    ※ 여기서 이미 난 큰 오류를 범한 것이다.
[int a[z + 1]] 의 원소값 보다 작은						※ 배열 첫 번째 부터 출발 하는 것이 아닌 거꾸로 시작해서 내려오는 식으로 했다면 (즉, 내림차순)
										※ 오류가 날 경우의 수가 많은 방식을 아에 시도하지 않았어도 됬을 것이다.
[z] 자릿값을 찾아내어 [m] 에 담아서						     ※ 요지는 굳이 이진 탐색에 집착해서 이렇게 어려운 길로 가게 된 것이다.
[int a[m]] 원소값 만큼 c에서 몫(동전, 지폐 사용 개수)과 나머지(잔돈)을 구한다.

그 후, [m--] 연산 후에 위의 절차를           // [m]가 0보다 아래로 갈 수 없도록 조건 걸어둠
최종적으로 [c] 가 0 이 될 때 까지            // 나머지(잔돈)이 ' 0 ' 이 될 때 까지
반복하게 되고, 최종적으로 [l] 의 값을        // [int a[0]] 의 원소값은 항상 ' 1 ' 이 주어진다. 
출력하면 된다.                              // (즉, 이론적으로 나머지가 남지 않는 다.)
================================================================
[반례]
5 4200
1
5
50
100
1000

이게 왜 틀렸는 지, 스스로 분석해라.
*/
