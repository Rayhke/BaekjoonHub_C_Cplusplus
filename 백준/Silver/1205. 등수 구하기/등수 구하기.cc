#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	int a = -1, N, O, P;
	cin >> N >> O >> P;
	if (N == 0 && N < P) { cout << 1; return 0; }
	vector <int> v(N);
	for (int n = 0; n < N; n++) { cin >> v[n]; }
	sort(v.begin(), v.end());
	for (int n = 0; n < N; n++) {
		if (O < v[n]) {					// ◆ 현재의 순위권 사람이 기록이 높은 경우
			if (N < P) { a = N - n + 1; }		// 순위권이 반영 되는 카운트를 벗어나지 않은 경우 
			break;
		}
		else if (O > v[n]) {				// ◆ 현재의 순위권 사람과 동점인 경우
			if (P >= N - n + 1) { a = N - n; }	// 순위권이 반영 되는 카운트를 벗어나지 않은 경우
			else { break; }
		}
		else { a = N - n; }				// ◆ 현재의 순위권 사람보다 기록이 높은 경우
	}
	if (a > P) { cout << -1; }
	else { cout << a; }
	return 0;
}
/* ■ 설명 ■
디맥 순위권이 반영 되는 방식을 떠올려 보며 해보면 쉽다.
주어진 [O] 점수가 특정 등수와 같은 점수라면, 같은 순위권을 공유 하되
랭킹 순으로는 같은 순위권 사람들 중에 가장 뒤로 배치된다.

그러할 때, 만약 순위권이 반영되는 [P] 순위권이 반영되는 카운트를		// 디맥은 내 순위권을 기준으로 얼추 ±100 즈음?만 보여줌
초과 하느냐 마느냐에 따라 반영 되는 결과를 다르게 할 것.

========================================================================
만약, 22번 째 줄 코드를 없이			// else { a = N - n; }
그냥 18번 째 줄에서 남아 있는 경우의 수를
다 시행 했을 경우에 문제가 있는 데		// else if (O >= v[n])
---------------------
[입력 값]
10 1 10
10 9 8 7 6 5 4 3 3 0
---------------------
[출력 값]
-1
---------------------
이렇게 출력된다. 
원인을 분석 해보면, 19번 째 줄 조건문
if (P >= N - n + 1)
*/
