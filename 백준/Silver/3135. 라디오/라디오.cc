#include <iostream>
using namespace std;

inline int s(int p, int q, int r) { return ((p - q) < r) ? (p - q) : r; }

int main() {
	int a, b, c, d, e = 1000;
	cin >> a >> b >> c;			// 목적지 주파수가 현재 위치 주파수 보다 위인지 아래인지 찾는 값이자
	a = (a > b) ? (a - b) : (b - a);	// 동시에 다이얼을 직접 조작 하였을 때, 조작 횟수 카운트
	for (int n = 0; n < c; n++) {
		cin >> d;
		if (d > b) { e = s(d, b, e); }	// 목적지 주파수 값 보다, 즐겨찾기 주파수 위치가 앞인 경우 
		else { e = s(b, d, e); }	// 목적지 주파수 값 보다, 즐겨찾기 주파수 위치가 뒤인 경우
	}
	e++;	// <- 중요
	if (a < e) { cout << a; }		// 다이얼 직접 돌려서 최소한으로 조작한 경우
	else { cout << e; }			// 즐겨찾기 버튼으로 최소한으로 조작한 경우
	return 0;
}
/* ■ 설명 ■	 // 백준 - 실버 5 (3135번)
라디오 조작을 최소한으로 하는 값을 구하는 문제이며

지금껏 이러한 유형의 문제를 마주쳤을 땐
배열을 종종 사용 했었으나, 비효율적이다.

때로는 미리 연산 작업을 하여,
작업 단계를 최소화 하는 발상을 떠올려 볼 것
=================================================================
[오답 원인] - 반례

<입력>
1 1
1
1
<출력>
1
<정답>
0

이러한 경우 문제가 발생하며,
마지막에 출력할 때, [if] 문 조건으로 (a < e) 으로 하게되면
둘다 0 이므로 [else] 문으로 빠져나와 ' e + 1 ' 결과값이 출력되어
원래 정답인 ' 0 ' 이 아닌 ' 1 ' 이 출력된다.
그러니 처음부터 ' e + 1 ' 을 한 결과값 기준으로 비교 연산을 할 것.
*/
